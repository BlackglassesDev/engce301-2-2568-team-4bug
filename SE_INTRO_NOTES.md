1. **บทบาทของวิศวกรซอฟต์แวร์ (Software Engineer Role)**
 
  ออกแบบระบบ UX/UI การพัมนาซอฟต์แวร์ พัฒนา Web App ให้ทันสมัยสวยงามเหมาะแก่ผู้ใช้ ได้เรียนรู้การทำงานเป็นทีมแบบแชร์การทำงาน การเขียนโปรแกรมแบบ Full-stack การวิเคราะห์หรือทดสอบระบบ

  **ระบุตัวอย่างงาน/กิจกรรม**  
  - วิเคราะห์ requirement  
  - ออกแบบระบบ  
  - เขียนโค้ด/ทดสอบ  
  - ประสานงานกับทีมอื่น  
    
  **บทบาทอื่นในทีม**
  - `Product Owner (PO)`
  เป็นตัวแทนของลูกค้า/ผู้ใช้/ผู้มีส่วนได้ส่วนเสีย มีหน้าที่ กำหนดวิสัยทัศน์ (Vision) และ ความสำคัญ (Priority) ของ Product Backlog (รายการงาน) รับผิดชอบในการตัดสินใจว่าฟีเจอร์ใดควรถูกพัฒนาเป็นอันดับแรกเพื่อให้ได้คุณค่าสูงสุด
  - `Quality Assurance (QA)`	
  มุ่งเน้นการ สร้างความมั่นใจในคุณภาพ ตลอดกระบวนการพัฒนา ทำงานตั้งแต่การทบทวนข้อกำหนด (Requirements Review) จนถึงการทดสอบขั้นสุดท้าย (End-to-End Testing) เพื่อให้ผลิตภัณฑ์มีมาตรฐานและเชื่อถือได้
  - `DevOps Engineer`	
  มีหน้าที่ เชื่อมช่องว่าง ระหว่างทีมพัฒนา (Dev) และทีมปฏิบัติการ (Ops) รับผิดชอบในการจัดการ Automation เช่น CI/CD Pipeline, การจัดการ Infrastructure (เช่น Cloud Server) และการดูแลการ Deploy ระบบให้รวดเร็วและเสถียร
  - `Business Analyst (BA)`
  เป็นผู้ วิเคราะห์ความต้องการทางธุรกิจ แปลงความต้องการของลูกค้าให้ออกมาเป็น ข้อกำหนดเชิงฟังก์ชัน (Functional Requirements) ที่ชัดเจน เพื่อให้ทีม SA/Design สามารถนำไปออกแบบระบบต่อได้
  - `Backend Developer`	
  รับผิดชอบในการพัฒนา ตรรกะทางธุรกิจ (Business Logic), การจัดการ API, และการเชื่อมต่อกับ ฐานข้อมูล (Database) เพื่อให้ระบบทำงานได้จากฝั่ง Server
  - `Scrum Master`	
  (เฉพาะในทีม Scrum) มีหน้าที่ อำนวยความสะดวก และดูแลให้ทีมปฏิบัติตามกฎและหลักการของ Scrum Model รวมถึงการ ขจัดอุปสรรค (Remove Impediments) และปกป้องทีมจากการถูกรบกวนจากภายนอก
  - `UI/UX Designer`
  รับผิดชอบในการออกแบบ ประสบการณ์ผู้ใช้ (User Experience - UX) และ ส่วนต่อประสานกับผู้ใช้ (User Interface - UI) โดยเน้นการทำให้ผลิตภัณฑ์ใช้งานง่าย, สวยงาม, และตอบโจทย์พฤติกรรมของผู้ใช้
  - `Database Administrator (DBA)`
  ดูแลและจัดการ ประสิทธิภาพ ความปลอดภัย และความพร้อมใช้งานของ ฐานข้อมูล รับผิดชอบในการติดตั้ง, กำหนดค่า, และบำรุงรักษา Server ฐานข้อมูลให้ทำงานได้อย่างราบรื่น
  - `Security Engineer / Architect`
  รับผิดชอบในการ ประเมินความเสี่ยง และออกแบบมาตรการ ความปลอดภัย ของระบบตั้งแต่เริ่มต้น (Security by Design) เพื่อป้องกันการโจมตีและการเข้าถึงข้อมูลโดยไม่ได้รับอนุญาต
  - `Release Manager`
  ควบคุมและวางแผนการ ปล่อยเวอร์ชันใหม่ ของซอฟต์แวร์ (Release) โดยดูแลให้กระบวนการตั้งแต่การพัฒนาจนถึงการติดตั้งบน Production เป็นไปอย่างราบรื่นและเป็นไปตามกำหนดเวลา

2. **ภาพรวม SDLC (Software Development Life Cycle)**

    ```text
    +--------------+   +--------+   +----------------+   +---------+   +-----------+   +------------+
    | Requirements | → | Design | → | Implementation | → | Testing | → | Deployment| → | Maintenance|
    +--------------+   +--------+   +----------------+   +---------+   +-----------+   +------------+
    ```

    ### Requirements
    ขั้นตอนนี้คือการ ทำความเข้าใจและกำหนดขอบเขต ของโปรเจกต์อย่างละเอียด โดยรวบรวมข้อมูลจากผู้มีส่วนได้ส่วนเสียทั้งหมด (เช่น ลูกค้า/อาจารย์) เพื่อจัดทำเอกสาร SRS (Software Requirements Specification) ที่ชัดเจน หากมีการเข้าใจผิดเกิดความคลาดเคลื่อนอาจทำให้เกิดการแก้ไขและเพิ่มต้นทุนโดยไม่จำเป็น

    ### Design
    ขั้นตอนนี้คือการกำหนดโครงสร้างของระบบ รวมถึงการออกแบบสถาปัตยกรรม, การออกแบบฐานข้อมูล, และการออกแบบส่วนติดต่อผู้ใช้ (UI/UX) ก่อนลงมือเขียนโค้ดจริง ทำให้การพัฒนาราบรื่น และดูแลแก้ไขง่าย

    ### Implementation
    ขั้นตอนนี้คือการเขียนโค้ด ตามเอกสารการออกแบบที่ได้จัดทำไว้ ทีมพัฒนาตามโครงสร้างให้กลายเป็นซอฟต์แวร์ที่ใช้งานได้จริงโดยใช้ภาษาและเครื่องมือที่กำหนดไว้ โดยคุณภาพของโค้ดจะส่งผลต่อความเสถียรและการดูแลในระยะยาว

    ### Testing
    ขั้นตอนนี้คือการค้นหาและแก้ไขข้อผิดพลาด เพื่อให้มั่นใจว่าซอฟต์แวร์ทำงานได้ถูกต้องตามข้อกำหนดที่ระบุไว้ในเฟสแรก มีการทดสอบหลายระดับ เช่น Unit Test, Integration Test และ System Test เพื่อตรวจสอบคุณภาพ หากการตรวจสอบหรือทดสอบไม่ละเอียดอาจส่งผลให้เกิดความเสียหายได้ในหลายๆด้าน

    ### Deployment
    ขั้นตอนนี้คือการนำซอฟต์แวร์ที่ผ่านการทดสอบแล้วไปติดตั้ง และเปิดให้ผู้ใช้งานจริงอย่างเป็นทางการ (เช่น การติดตั้งบน Production Server) พร้อมปรับระบบให้อยู่ในสภาพแวดล้อมที่เหมาะสม มีความปลอดภัยและพร้อมใช้งาน

    ### Maintenance
    ขั้นตอนนี้คือการดูแลและปรับปรุงระบบ หลังจากที่ใช้งานจริง เพื่อแก้ไขปัญหาที่เพิ่งถูกค้นพบ, การปรับปรุงประสิทธิภาพ, หรือการเพิ่มฟีเจอร์ใหม่ ๆ ตามความต้องการที่เปลี่ยนแปลงไปในอนาคต

3. **Waterfall vs Agile – ตารางเปรียบเทียบ**

     | **หัวข้อการเปรียบเทียบ** | **Waterfall** | **Agile (Scrum/Kanban)** |
     |:---:| :---:| :---:|
     | การวางแผน | วางทีเดียวระยะยาว | วางแผนเป็นรอบสั้น ๆ (Sprint) |
     | การส่งมอบงาน | ส่งตอนท้ายโครงการ | ส่งบ่อย ๆ เป็น Increment |
     | การเปลี่ยนแปลง | เปลี่ยนยาก/เสี่ยงสูง | ยอมรับและวางแผนสำหรับการเปลี่ยนแปลง |
     | การสื่อสารกับลูกค้า | น้อย/เป็นทางการ | สื่อสารสม่ำเสมอ ร่วม review ผลงาน |
    
     ## การประยุกต์ใช้กับ Term Project ของกลุ่มเรา
### 1) ถ้า Term Project ใช้ Waterfall 100% กลุ่มเราคิดว่าจุดเด่น/ข้อจำกัดคืออะไร? (อย่างน้อย 3 ข้อ)

  | **จุดเด่น (Pros)** | **ข้อจำกัด (Cons)** |
  | :---: | :---: |
  | 1. บันทึกรายละเอียดโครงการอย่างเป็นขั้นตอน |  การเปลี่ยนแปลง (Requirements) ระหว่างขั้นตอนทำได้ยาก |
  | 2. การวางแผนกำหนดการที่แม่นยำ | หากมีความเข้าใจ Requirement ผิด อาจจะสายเกินไปที่จะแก้ไข |
  | 3. ง่ายต่อการบำรุงรักษาและส่งมอบ |  ต้องการ ข้อกำหนดที่ชัดเจนและมั่นคง |

### 2) ถ้า Term Project ใช้ Agile (แบ่งเป็น Sprints) จุดเด่น/ข้อจำกัดคืออะไร? (อย่างน้อย 3 ข้อ)

  | **จุดเด่น (Pros)** | **ข้อจำกัด (Cons)** |
  | :---: | :---: |
  | 1. **มีความยืดหยุ่นต่อการเปลี่ยนแปลง** เพราะแบ่งเป็น Sprints ทำให้การเปลี่ยนแปลงไม่เกิดความเสียหายขนาดใหญ่ |  ต้องการวินัยและความเข้าใจในกระบวนการสูง |
  | 2. มีการ **Feedback ที่รวดเร็ว** ทำให้ตรงตามความต้องการ และป้องกันการทำงานผิดทิศทาง | เอกสารอาจไม่ละเอียดเท่าที่ต้องการ |
  | 3. ส่งเสริมการทำงานเป็นทีมและการปรับปรุงอย่างต่อเนื่อง |  **ต้องการการมีส่วนร่วมจากผู้มีส่วนได้ส่วนเสียอย่างสม่ำเสมอ** ถ้าขาดผู้มีส่วนร่วมจะทำให้ทีมขาดทิศทางและประโยชน์ของ Agile จะลดลงทันที |

### 3) สุดท้าย กลุ่มเราอยากใช้ approach แบบไหน หรือ hybrid แบบใด? เพราะเหตุใด?
     
